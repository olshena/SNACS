---
title: "SNACS"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SNACS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  comment = "#>"
)
```
## Overview
SNACS is an R package for demultiplexing hashes which have simultaneous profiles of single-cell genetic mutations and cell surface antibodies. It identifies the hash of each cell in the mutation data where multiple hashes were profiled concurrently. The hash designations are made based on the mutation and the hash antibody data.

## Load SNACS package
The first step is to load the SNACS package.
```{r setup}
library(SNACS)
```

## Input data format
We have to properly format the input data. SNACS required  a matrix containing the single cell mutation data from the multiplexed profiles of subjects and a matrix containing the hash antibody data of each subject. The mutation data should be a numeric matrix with SNPs in the rows and cells in the columns. 1s represent mutations and 0s non-mutations. The antibody data should be a matrix with subjects in the rows and cells in the columns. The hash antibody values should be continuous numeric measures. Optional cell and SNP level annotations can be provided as data frames.

## Example data
An example data has been included with the package. It has mutation and antibody data from 3 subjects with 750 cells and 24 SNPs. We will demonstrate the package with this data.

Matrix "mutMat" has the mutation data.

```{r, echo = TRUE}

dim(mutMat)
mutMat[1:4,1:4]

```
Matrix "hashMat" has the has antibody data.

```{r, echo = TRUE}

dim(hashMat)
hashMat[,1:4]

```
Matrix "depthTotalMat" has the total depth data.

```{r, echo = TRUE}

dim(depthTotalMat)
depthTotalMat[1:4,1:4]

```
Matrix "depthAltMat" has the alternate depth data.

```{r, echo = TRUE}

dim(depthAltMat)
depthAltMat[1:4,1:4]

```
## Create SNACSList object
SNACS stores data in a simple list-based data object called a SNACSList. The SNACSList object can be made for the example data as follows.
```{r, echo = TRUE}

## Parameters mut, hashes, exptName are mandatory while depthTotalMat, depthAltMat and hashColors are optional. depthTotalMat and depthAltMat are used for making doubletD calls
exptName <- "snacsExpt"
hashColors <- c("indianred2","green3","dodgerblue3")

snacsObj <- SNACSList(mut=mutMat,hashes=hashMat,exptName=exptName,depthTotal=depthTotalMat,depthAlt=depthAltMat,hashColors=hashColors)
snacsObj

```

## Filter data
SNPs and cells with high proportion of missing values should be excluded. We will also filter out SNPs with low or high proportion of mutations.

```{r, echo = TRUE}

snacsObj <- filterData(snacsObj=snacsObj)
snacsObj

```

## Cluster antibody data to select best SNPs to demultiplex hashes
First, hash antibody data is used to classify cells into n preliminary groups, where n is the number of parent samples and thus hash antibodies. For each hash antibody, the antibody expression for a multiplexed experiment is expected to be bimodal, with one right mode comprised of antibody-stained cells belonging to a single parent sample and one left mode comprised of unstained cells from alternate parent samples. To estimate the background antibody distribution, a symmetric distribution is generated by reflecting the data to the left of the left mode about that mode. Cells are assigned to a specific hash antibody if the antibody expression of that cell is expressed highly; a threshold of the 95th percentile of the background distribution is used to consider a cell to be positive for a hash. Cells that are assigned to either multiple hashes or to no hashes are excluded in this step.

Then the SNPs that best distinguish the hash-antibody-defined groups from above step are selected by comparing the proportion of mutated (i.e., 1) values pairwise between hash groups and ranking these comparisons using a one-sided chi-square test.  The test is one-sided to identify SNPs that have a higher proportion of positivity for each comparison. For each of n groups, n – 1 comparisons are performed, and for each comparison, the top k SNPs are chosen. The value of k is user-defined withe the default being three. The result of the comparisons identifies a total of n*(n – 1)*k SNPs that separate groups, but as the same SNPs may be chosen for more than one comparison, the selection is confined to the unique subset of SNPs.
```{r, echo = TRUE}

snacsObj <- getBestSNPs(snacsObj)
snacsObj

```

## Impute missing mutations
Currently, SNACS package cannot work on SNPs with missing values. SNACS imputes missing mutations using k nearest neighbor approach.

```{r, echo = TRUE}

snacsObj <- imputeMissingMutations(snacsObj=snacsObj)
snacsObj

```

## Cluster cells based on the SNP data
Cluster cells, where the number of clusters is the number of constituent samples, using the mutation data with the selected SNPs. These clusters will be used to make SNACS calls.

```{r, echo = TRUE}

snacsObj <- clusterCellsWithSNPdata(snacsObj)
snacsObj

```

## Make SNACS calls
The resulting dendrogram from the previous step is cut into n clusters. Clusters are further identified by traversing down the hierarchical tree and splitting if a significant difference is found when comparing the daughter nodes of any current node.  The comparisons are made for every hash antibody, and the two-sample t-test with equal variances is used to test for differences using an unadjusted p-value threshold of 10-5. The process is stopped when no additional differences are found or there are at least two cells in a cluster.

Clusters are then assigned to a specific hash antibody and parent sample by comparing the antibody expression of the cluster to the hash background distributions as described in a previous section. A cluster is assigned to a hash if > 50% of cells from that cluster have a hash expression that exceeds the 95th percentile of the background distribution. Clusters assigned to multiple hashes are designated as multiplets, and clusters not assigned to a hash antibody are designated “no call”. In the SNACS R package, the output and visualization of this initial demultiplexing is designated “SNACS Round 1”.

As accurately detecting multiplets is a significant concern in multiplexed SC data, the calling of multiplets is refined using hash antibody data. The mean hash antibody expression is estimated for each hash based on the cell clusters that were uniquely assigned to that hash in SNACS Round 1.  Then, the Euclidean distance to the cluster center for every cell and hash was estimated.  Within each cluster, using the ordering of the cells determined by the clustering, we the distance value for every hash was segmented by using circular binary segmentation (CBS), an algorithm designed to indentify contiguous regions of homogenous DNA copy in the genome by estimating changepoints in sequential data. The superset of all changepoints is then used to form new clusters, and those new clusters are then, possibly, reassigned in multiplets using the same approach as described in the previous section. In this round, only narrow segments are considered; choosing fewer than 100 cells as narrow.  Additionally, to provide additional power in this step, the hash background cutoff was the 75th percentile instead of the 95th. This output is called “SNACS Round 2”.

```{r, echo = TRUE}

snacsObj=makeSnacsCall(snacsObj)

## The SNACS calls are saved in the "annCell" table in the SNACSList object
snacsObj$annCell[1:4,]

```

## Detection of additional multiplet cells via combination with doubletD
The capability to call multiplets at the single-cell level by incorporating the previously-published doubletD algorithm is also available. In doubletD, matrices of total and alternate allele depth for each single-cell barcode are used to identify doublets based on increased allele frequency and/or drop-out via an expectation-maximization approach. For each single cell in a multi-sample experiments, the cell is considered a multiplet if it was called a multiplet by SNACS, as detailed above, or by doubletD. In the SNACS R package, the output and visualization of this optional subsequent refinement step is designated “SNACS plus doubletD”. Of note, although the mathematics of the doubletD algorithm are identical to those previously published, the author-supplied code was treanslated from python to R for seamless incorporation into the SNACS software.

```{r, echo = TRUE}

snacsObj=runSNACSplusDoubletD(snacsObj)

## The SNACS plus doubletD based SNACS calls are saved in the "annCell" table in the SNACSList object
snacsObj$annCell[1:4,]

```

## Generate annotated heatmap
Heatmap of the SNP data with cell and SNP annotations can be generated. Here the heatmap of the best SNPS are annotated with color bars for the SNACS calls along with the clusters from the first round of clustering, and the hash antibody measures.
The parameter "outputFormat" can be used to save the heatmap in "pdf" or "png" format. The output is then saved in "../output" folder.

```{r, fig.show = "hold", out.width = "100%", echo = TRUE}

createHeatmap(snacsObj,
   cell_anno_var=c("snacsPlusDoubletD","doubletD","snacsRnd2","snacsRnd1",snacsObj$annHash$hashNames,"clustBestSNPs_hclust"),
   cell_anno_name=c("snacs+DD","doubletD","snacsRnd2","snacsRnd1",snacsObj$annHash$hashNames,"cluster"),
   outputFormat="")

```

