---
title: "SNACS"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SNACS}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  warning = FALSE,
  comment = "#>"
)
```
## Overview
Single Nucleotide Polymorphism (SNP) and Antibody-based Cell Sorting (SNACS) is a tool for demultiplexing single-cell DNA sequencing data. It combines both SNP and barcoding based approaches for demultiplexing and multiplet identification based upon DAb-seq technology.

## Load SNACS package
The first step is to load the SNACS package.
```{r setup}
library(SNACS)
```

## Input data format
SNACS requires a matrix containing the single cell SNP data from the multiplexed profiles of parent samples and a matrix containing the hash antibody data of each sample. The mutation data should be a numeric matrix with SNPs in the rows and cells in the columns. 1s represent mutations and 0s non-mutations. The antibody data should be a matrix with samples in the rows and cells in the columns. The hash antibody values should be continuous numeric measures. Optional cell and SNP level annotations can be provided as data frames.

## Example data
An example data has been included with the package. It has mutation and antibody data from 3 parent samples with 739 cells and 22 SNPs. We will demonstrate the package with this data.

Matrix "mutMat" has the mutation data.

```{r, echo = TRUE}

dim(mutMat)
mutMat[1:4,1:4]

```
Matrix "hashMat" has the hash antibody data.

```{r, echo = TRUE}

dim(hashMat)
hashMat[,1:4]

```
Matrix "depthTotalMat" has the total allele depth data. This information has to be provided if one wants to run the additional SNACS + doubletD analysis.

```{r, echo = TRUE}

dim(depthTotalMat)
depthTotalMat[1:4,1:4]

```
Matrix "depthAltMat" has the alternate allele depth data. This information is also needed if one wants to run SNACS + doubletD analysis.

```{r, echo = TRUE}

dim(depthAltMat)
depthAltMat[1:4,1:4]

```
## Create SNACSList object
SNACS stores data in a simple list-based data object called a SNACSList. The SNACSList object can be made for the example data as follows.
```{r, echo = TRUE}

## Parameters mut, hashes, exptName are mandatory while depthTotalMat, depthAltMat and hashColors are optional. depthTotalMat and depthAltMat are used for making doubletD calls
exptName <- "snacsExpt"
hashColors <- c("indianred2","green3","dodgerblue3")

snacsObj <- SNACSList(mut=mutMat,hashes=hashMat,exptName=exptName,depthTotal=depthTotalMat,depthAlt=depthAltMat,hashColors=hashColors)
snacsObj

```

## Filter data
SNPs and cells with high proportion of missing values should be excluded. We will also filter out SNPs with low or high proportion of mutations. For the example data, all SNPs and cells meet the filtering criteria.

```{r, echo = TRUE}

snacsObj <- filterData(snacsObj=snacsObj)
snacsObj

```

## Cluster antibody data to select best SNPs to demultiplex hashes
First, hash antibody data is used to classify cells into n preliminary groups, where n is the number of parent samples and thus hash antibodies. For each hash antibody, the antibody expression for a multiplexed experiment is expected to be bimodal, with one right mode comprised of antibody-stained cells belonging to a single parent sample and one left mode comprised of unstained cells from alternate parent samples. To estimate the background antibody distribution, a symmetric distribution is generated by reflecting the data to the left of the left mode about that mode. Cells are assigned to a specific hash antibody if the antibody expression of that cell is expressed highly; a threshold of the 95th percentile of the background distribution is used to consider a cell to be positive for a hash. Cells that are assigned to either multiple hashes or to no hashes are excluded in this step.

Then the SNPs that best distinguish the hash-antibody-defined groups from above step are selected by comparing the proportion of mutated (i.e., 1) values pairwise between hash groups and ranking these comparisons using a one-sided chi-square test.  The test is one-sided to identify SNPs that have a higher proportion of positivity for each comparison. For each of n groups, n – 1 comparisons are performed, and for each comparison, the top k SNPs are chosen. The value of k is user-defined with the default being three. The result of the comparisons identifies a total of n*(n – 1)*k SNPs that separate groups, but as the same SNPs may be chosen for more than one comparison, the selection is confined to the unique subset of SNPs.

This step generates density plots of the hash antibody data that show the bimodal distributions of the data. The 95th percentile threshold that separates the expressed cells from the background is marked on the plots.

```{r, echo = TRUE}

snacsObj <- getBestSNPs(snacsObj)
snacsObj

```

## Impute missing mutations
Currently, SNACS package cannot work on SNPs with missing values. SNACS imputes missing mutations using k-nearest neighbors approach.

```{r, echo = TRUE}

snacsObj <- imputeMissingMutations(snacsObj=snacsObj)
snacsObj

```

## Cluster cells based on the SNP data
Cluster cells, where the number of clusters is the number of constituent samples, using the mutation data of the selected SNPs. These clusters will be used to make SNACS calls.

```{r, echo = TRUE}

snacsObj <- clusterCellsWithSNPdata(snacsObj)
snacsObj

```

## Make SNACS calls
The resulting dendrogram from the previous step is cut into n clusters. Clusters are further identified by traversing down the hierarchical tree and splitting if a significant difference is found when comparing the daughter nodes of any current node.  The comparisons are made for every hash antibody, and the two-sample t-test with equal variances is used to test for differences using an unadjusted p-value threshold of 10-5. The process is stopped when no additional differences are found or there are only two cells in a cluster.

Clusters are then assigned to a specific hash antibody and parent sample by comparing the antibody expression of the cluster to the hash background distributions as described in a previous section. A cluster is assigned to a hash if > 50% of cells from that cluster have a hash expression that exceeds the 95th percentile of the background distribution. Clusters assigned to multiple hashes are designated as multiplets, and clusters not assigned to a hash antibody are designated “no call”. This initial demultiplexing is designated “SNACS Round 1”.

As accurately detecting multiplets is a significant concern in multiplexed SC data, the calling of multiplets is refined using hash antibody data. The mean hash antibody expression is estimated for each hash based on the cell clusters that were uniquely assigned to that hash in SNACS Round 1.  Then, the Euclidean distance to the cluster center for every cell and hash is estimated.  Within each cluster, using the ordering of the cells determined by the clustering, the distance value for every hash is segmented by using circular binary segmentation (CBS), an algorithm designed to identify contiguous regions of homogenous DNA copy in the genome by estimating changepoints in sequential data. The superset of all changepoints is then used to form new clusters, and these new clusters are then, possibly, reassigned in multiplets using the same approach as described in the previous section. In this round, only narrow segments are considered; choosing 100 or fewer cells as narrow. Additionally, to provide additional power in this step, the hash background cutoff used is the 75th percentile instead of the 95th. This output is called “SNACS Round 2”.

```{r, echo = TRUE}

snacsObj=makeSnacsCall(snacsObj)

## The SNACS calls are saved in the "annCell" table in the SNACSList object
snacsObj$annCell[1:4,]

```

## Detection of additional multiplet cells via combination with doubletD
The capability to call multiplets at the single-cell level by incorporating the previously-published doubletD algorithm is also available. In doubletD, matrices of total and alternate allele depth for each single-cell barcode are used to identify doublets based on increased allele frequency and/or drop-out via an expectation-maximization approach. For each single cell in a multi-sample experiment, the cell is considered a multiplet if it was called a multiplet by SNACS, as detailed above, or by doubletD. The output of this optional subsequent refinement step is designated “SNACS plus doubletD”. Of note, although the mathematics of the doubletD algorithm are identical to those previously published, the author-supplied code was translated from python to R for seamless incorporation into the SNACS software.

```{r, echo = TRUE}

snacsObj=runSNACSplusDoubletD(snacsObj)

snacsObj$annCell[1:4,]

```

## Visualization with annotated heatmap of SNP data
Heatmap of the SNP data with cell annotation can be generated. Here the heatmap of the best SNPs are annotated with color bars for the SNACS calls along with the clusters from the first round of clustering, and the hash antibody measures.
The parameter "outputFormat" can be used to save the heatmap in "pdf" or "png" format. The output is then saved in "../output" folder.

```{r, fig.show = "hold", out.width = "100%", echo = TRUE}

createHeatmap(snacsObj,
   cell_anno_var=c("snacsPlusDoubletD","doubletD","snacsRnd2","snacsRnd1",snacsObj$annHash$hashNames,"clustBestSNPs_hclust"),
   cell_anno_name=c("snacs+DD","doubletD","snacsRnd2","snacsRnd1",snacsObj$annHash$hashNames,"cluster"),
   outputFormat="")

```

